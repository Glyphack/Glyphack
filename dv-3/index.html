<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width"><link rel=icon type=image/ico href=https:/glyphack.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https:/glyphack.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https:/glyphack.com/favicon-32x32.png><link rel=icon type=image/png sizes=192x192 href=https:/glyphack.com/android-chrome-192x192.png><link rel=apple-touch-icon sizes=180x180 href=https:/glyphack.com/apple-touch-icon.png><meta name=description content><title>Devlog 3: Coding a redis clone in C and things I learned | Glyphack</title><link rel=canonical href=https://glyphack.com/dv-3/><meta property="og:url" content="https://glyphack.com/dv-3/"><meta property="og:site_name" content="Glyphack"><meta property="og:title" content="Devlog 3: Coding a redis clone in C and things I learned"><meta property="og:description" content="About two months ago I started the build your own Redis challenge from https://codecrafters.io. I decided to do this in C. Initially I was just curious to do it in C. Doing it in C thought me a lot of stuff that otherwise I would have not learned. Another bonus point was that I could tweak the performance to be on par with Redis server.
C always seemed like an impossible language to me. Working so much in garbage collected languages with rich standard libraries made me think C is hard. Now I think C is not hard. Whatever you write gets executed the way you wrote it. Little abstractions make it a great language to implement what you want and have control over your program. Topics like Async programming, managing memory are broad topics. I agree that it’s hard to achieve the same level of concurrency that you have in Python in C. But writing a small version that works for a specific use case is not impossible. It’s possible to implement hash map, Async, memory arena(for easier memory management), and your own string type with a few lines of C code, thanks to blogs like null program"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-02-15T18:02:46+01:00"><meta property="article:modified_time" content="2025-02-15T18:02:46+01:00"><meta property="article:tag" content="Coding"><meta property="article:tag" content="Devlog"><link rel=stylesheet href=/assets/combined.min.455b53327434f234e64209735e8469bb37465ce15a3ebc45a1a586dd5e74c673.css media=all><script async defer data-website-id=e8710f0c-a6f2-4d2d-8b95-ef6b66e72226 src=https://cloud.umami.is/script.js></script></head><body class=light><div class=content><header><div class=header><h1 class=header-title><a href=https://glyphack.com/>Glyphack</a></h1><div class=flex><p class=small><a href=/>/Home</a></p><p class=small><a href=/blog/>/Blog</a></p><p class=small><a href=/projects/>/Projects</a></p><p class=small><a href=/now/>/Now</a></p><p class=small><a href=/reading-list/>/Reading List</a></p><p class=small><a href=https://r.glyphack.com/s/s>/Reads This</a></p><p class=small><a href="https://docs.google.com/document/d/1XgC2Va8ZgJ2DrmRKpgd_7iVjv8aASnn8nzl6DgkR1mg/edit?usp=sharing">/Resume</a></p></div></div></header><main class=main><div class=breadcrumbs><a href=/>Home</a><span class=breadcrumbs-separator>/</span><a href=/blog/>Blog</a><span class=breadcrumbs-separator>/</span>
<a href=/dv-3/>Devlog 3: Coding a redis clone in C and things I learned</a></div><div><article><header class=single-intro-container><h1 class=single-title>Devlog 3: Coding a redis clone in C and things I learned</h1><p class=single-readtime><time datetime=2025-02-15T18:02:46+01:00>February 15, 2025</time></p></header><div class=single-content><p>About two months ago I started the build your own Redis challenge from <a href=https://codecrafters.io>https://codecrafters.io</a>.
I decided to do this in C. Initially I was just curious to do it in C. Doing it in C thought me a lot of stuff that otherwise I would have not learned. Another bonus point was that I could tweak the performance to be on par with Redis server.</p><p>C always seemed like an impossible language to me. Working so much in garbage collected languages with rich standard libraries made me think C is hard.
Now I think C is not hard. Whatever you write gets executed the way you wrote it. Little abstractions make it a great language to implement what you want and have control over your program.
Topics like Async programming, managing memory are broad topics. I agree that it&rsquo;s hard to achieve the same level of concurrency that you have in Python in C. But writing a small version that works for a specific use case is not impossible.
It&rsquo;s possible to implement hash map, Async, memory arena(for easier memory management), and your own string type with a few lines of C code, thanks to blogs like <a href=https://nullprogram.com>null program</a></p><p>I think I&rsquo;ll use the below techniques I learned for any C program I create. I wish it was easier to package them so I can reuse it in different projects.</p><p>The source code is at <a href=https://github.com/Glyphack/redis-clone>glyphack/redis-clone</a>.</p><p>The below are things I learned about C programming.</p><h2 class=heading id=awesome-compiler-flags>Awesome Compiler Flags
<a class=anchor href=#awesome-compiler-flags>#</a></h2><p>I don&rsquo;t know why nobody told me this. C can have stacktraces. It can detect race conditions. It can detect use after free. It can do a lot of stuff by just adding more compiler flags.</p><p>You can compile your program with flags:</p><ul><li><code>-fsanitize=undefined</code> to crash on undefined behavior scenarios</li><li><code>-fsanitize=thread</code> to crash when threads have race condition(this is actually what powers Golang race detector)</li></ul><p>And if there is a race condition in your program you will see something like:</p><pre tabindex=0><code>==================
WARNING: ThreadSanitizer: data race (pid=12345)
  Read of size 4 at 0x000000601040 by thread T2:
    #0 thread_func (source.c:7) in main
    #1 start_thread (pthread_create.c:XXX)

  Previous write of size 4 at 0x000000601040 by thread T1:
    #0 thread_func (source.c:7) in main
    #1 start_thread (pthread_create.c:XXX)

  Location is global &#39;shared_var&#39; defined in source.c:5
==================
</code></pre><p>I built my program in debug mode with these flags and ran a tester that would insert and get values from the server. It detected a lot of bugs for me while pointing out the exact line the problem happened.</p><h2 class=heading id=memory-arena>Memory Arena
<a class=anchor href=#memory-arena>#</a></h2><p>I used a <a href=https://nullprogram.com/blog/2023/09/27/>memory arena</a> to minimize the number of <code>malloc</code> and <code>free</code> calls in the code.
It makes code faster but in the end I realized how much simplified the code gets.
It&rsquo;s basically like having a garbage collector and you know when it happens.</p><h2 class=heading id=custom-string-type>Custom String Type
<a class=anchor href=#custom-string-type>#</a></h2><p>One of the problems I faced soon after working with C was that, sometimes I wanted to keep a reference to middle of a giant string. Imagine you get a request and extract a field name from it. Now you have two options, either <code>memcpy</code> that substring into a new string and add a <code>\0</code> or make a pointer to the starting offset of the substring.
When you keep the offset you cannot use it in most of other places because you don&rsquo;t know the end of this string, and C strings end with <code>\0</code>.
I followed the advice in <a href=https://nullprogram.com/blog/2023/10/08/>this post</a> and it made code a lot smaller(no extra string creation and <code>malloc</code> calls) and simpler because working with a string when you know the length is just easier. Plus if you are worried you would lose the benefits of C string functions don&rsquo;t worry there is not much functionality there. You can implement it yourself.</p><h2 class=heading id=hash-map>Hash Map
<a class=anchor href=#hash-map>#</a></h2><p>I followed <a href=https://nullprogram.com/blog/2023/09/30/>this post</a> to implement a hash map. Initially my program was using a thread per connection so I tried to extend the lock free version to work with my program.
In the end I implemented Asynchronous code to handle multiple connections, removed the threads, and just used the hash map that is explain in the post.</p><h2 class=heading id=redis-replication>Redis Replication
<a class=anchor href=#redis-replication>#</a></h2><p>The Redis replication is initially simple to implement I did not implement the full protocol.
The basic functionality is to handshake with the master node and master node has to keep a list of replicas to forward write messages to.
The way multiple nodes stay in sync is by using replication offset that master checks for periodically. I did not implement any recovery case for when a replica is out of sync.</p><h2 class=heading id=asynchronous-programming>Asynchronous Programming
<a class=anchor href=#asynchronous-programming>#</a></h2><p>This is my favorite topic. I finally got a clue what actually happens in higher level languages. Before actually doing this I read and heard some words but it all felt like buzzwords to me.
What does it mean each coroutine has a stack? Why can&rsquo;t you run a blocking task inside an asynchronous function? I learned all after I implemented this.</p><p>The interesting part is, implementing basic asynchronous I/O is not hard, making it general and cross platform is. This is what other programming languages did.</p><p>To serve multiple clients concurrently we need a way to read from all of them without ever waiting for one client and <strong>blocking</strong> others.
So what we really need is, a way to tell which clients are ready to read, which are ready to write and instead of waiting for the ones that are not ready just skip and serve other clients.
I recommend following <a href=https://build-your-own.org/redis/05_event_loop_intro>this guide</a>. I ended up switching to <code>kqueue</code> from <code>poll</code> to achieve better performance on MacOS.</p><hr><p>I think this database can be a good base program to expand to any kind of future databases I want to write.
I can reuse the existing protocol to exchange messages and add my custom logic or <a href=https://eli.thegreenplace.net/2020/implementing-raft-part-0-introduction/>implement Raft</a>.</p></div></article><div class=single-pagination><hr><div class=flexnowrap><div class=single-pagination-prev><div class=single-pagination-container-prev><div class=single-pagination-text>←</div><div class=single-pagination-text><a href=/fooled-by-data/>Can Data Fool You?</a></div></div></div><div class=single-pagination-next><div class=single-pagination-container-next><div class=single-pagination-text><a href=/after-interview/>After Interview</a></div><div class=single-pagination-text>→</div></div></div></div><hr></div><div class=back-to-top><a href=#top>back to top</a></div></div></main></div><footer><p>Powered by
<a href=https://gohugo.io/>Hugo</a>
and
<a href=https://github.com/tomfran/typo>tomfran/typo</a></p></footer></body><script src=/js/theme-switch.js></script><script defer src=/js/copy-code.js></script></html>